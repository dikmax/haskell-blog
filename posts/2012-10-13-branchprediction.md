---
title: Branch prediction
date: 2012-10-13T12:29:51+03:00
tags: javascript, программирование, производительность
---

Есть такая вещь в современных и не очень процессорах, называется [предсказатель переходов](http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%BE%D0%B4%D0%BE%D0%B2) ([branch predictor](http://en.wikipedia.org/wiki/Branch_predictor)). Он позволяет значительно увеличить скорость работы процессора. Недавно мне [Антон](http://itground.by) прислал ссылку на обсуждение предсказателя переходов на Stack Overflow. И там есть [очень хорошее объяснение](http://stackoverflow.com/a/11227902/682727), обязательно посмотрите.

Так вот, я решил проверить, насколько все это применимо к JavaScript. Ведь, хотя это и интерпретируемый язык, во все последние браузеры встроен JIT-компилятор. И логично предположить, что производительность будет страдать от плохо предсказываемых переходов. Как оказалось, идея такого исследования не мне первому пришла в голову и на [jsPerf](http://jsperf.com) нашелся соответствующий тест. Я добавил еще несколько интересных вариантов и готов поделиться результатами.

Сначала о самом тесте. У нас есть 2 одинаковых случайных массива с числами от 0 до 255. Потом один из них мы сортируем. Ну и смотрим, с какой скоростью посчитается сумма всех элементов массива больших или равных 128.

Есть 2 основных способа это сделать: с помощью `if` и с помощью тернарного оператора.

~~~~~javascript
var sum = 0;
for (var j = 0; j < arraySize; ++j) {
  if (unsorted[j] > 128) {
    sum += unsorted[j];
  }
}
~~~~~

~~~~~javascript
var sum = 0;
for (var j = 0; j < arraySize; ++j) {
  sum += unsorted[j] >=128 ? unsorted[j] : 0;
}
~~~~~

Ну и третий способ --- небольшая оптимизация второго:

~~~~~javascript
var sum = 0, item;
for (var j = 0; j < arraySize; ++j) {
  item = unsorted[j];
  sum += item >=128 ? item : 0;
}
~~~~~

[![Результаты](http://a51056ce8d9b948fb69e-8de36eb37b2366f5a76a776c3dee0b32.r42.cf1.rackcdn.com/branch-prediction.png)](http://jsperf.com/branch-prediction/2)

Что хочется отметить. У Google Chrome действительно хороший JIT-компилятор, и разница в скорости выполнения хорошо заметна. В случае Firefox не все так гладко. В оригинальном варианте с `if` разница в скорости в 2 раза, как и в случае Chrome. А вот тернарный оператор почему-то работает значительно медленнее, и разница между отсортированным и неотсортированным массивом не так заметна. Opera вообще все равно, хотя проход по отсортированному массиву все-таки немного быстрее. И еще для Opera имеет значение, что мы сделали 1 обращение к элементу массива вместо двух. Подозреваю, что такая оптимизация в ее компиляторе не предусмотрена. 

Про Internet Explorer ничего не скажу, у меня его нет. Если не трудно, [перейдите по ссылке](http://jsperf.com/branch-prediction/2) в IE и нажмите Run Tests.
